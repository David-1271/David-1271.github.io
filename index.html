<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>David's Portfolio</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
  </head>

  <body class="index-page">
    <div id="maze-container">
      <canvas id="maze-canvas"></canvas>
    </div>

    <div class="content-overlay">
      <div class="card" style="width: 450px; max-width: 90%;">
        <div class="card-body">
            <h1 class="text-center mb-4">David Lawlor</h1>
            <h5 class="text-center mb-4">Computer Science</h5>
          <ul class="nav flex-column">
            <li class="nav-item" align="center"><a class="nav-link" href="projects.html">Projects</a></li>
            <li class="nav-item" align="center"><a class="nav-link" href="about.html">About</a></li>
            <li class="nav-item" align="center"><a class="nav-link" href="contact.html">Contact Me</a></li>
          </ul>
        </div>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('maze-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        const cellSize = 20;
        const cols = Math.ceil(canvas.width / cellSize);
        const rows = Math.ceil(canvas.height / cellSize);

        const grid = [];
        for (let y = 0; y < rows; y++) {
          grid[y] = [];
          for (let x = 0; x < cols; x++) {
            grid[y][x] = {
              x, y,
              isWall: true,
              distance: Infinity,
              previous: null,
              visited: false,
              inQueue: false,
              exploredTime: null
            };
          }
        }

        class DisjointSet {
          constructor(size) {
            this.parent = Array.from({ length: size }, (_, i) => i);
            this.rank = Array(size).fill(0);
          }
          find(i) {
            return this.parent[i] === i ? i : (this.parent[i] = this.find(this.parent[i]));
          }
          union(a, b) {
            a = this.find(a);
            b = this.find(b);
            if (a === b) return;
            if (this.rank[a] < this.rank[b]) this.parent[a] = b;
            else if (this.rank[a] > this.rank[b]) this.parent[b] = a;
            else { this.parent[b] = a; this.rank[a]++; }
          }
        }

        <!-- Kruskals Maze Generation Algorithm-->
        function generateMaze() {
          for (let y = 1; y < rows; y += 2)
            for (let x = 1; x < cols; x += 2)
              grid[y][x].isWall = false;

          const edges = [];
          for (let y = 1; y < rows; y += 2) {
            for (let x = 1; x < cols; x += 2) {
              if (x + 2 < cols) edges.push({ x1: x, y1: y, x2: x + 2, y2: y, wx: x + 1, wy: y });
              if (y + 2 < rows) edges.push({ x1: x, y1: y, x2: x, y2: y + 2, wx: x, wy: y + 1 });
            }
          }

          edges.sort(() => Math.random() - 0.5);
          const dsu = new DisjointSet(rows * cols);

          for (const e of edges) {
            const a = e.y1 * cols + e.x1;
            const b = e.y2 * cols + e.x2;
            if (dsu.find(a) !== dsu.find(b)) {
              dsu.union(a, b);
              grid[e.wy][e.wx].isWall = false;
              grid[e.y2][e.x2].isWall = false;
            }
          }

          grid[1][1].isWall = false;
          grid[rows - 2][cols - 2].isWall = false;
        }

        generateMaze();

        let animationFrame = 0;
        let finalPath = [];
        let pathAnimationStart = null;

        function drawMaze() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const c = grid[y][x];
              ctx.fillStyle = c.isWall ? '#d4c4a8'
                : c.exploredTime !== null ? 'rgba(169,132,103,0.25)'
                : '#f5ede1';
              ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
            }
          }

          if (finalPath.length > 1 && pathAnimationStart !== null) {
            const progress = Math.min(
              finalPath.length,
              Math.floor((animationFrame - pathAnimationStart) / 3)
            );

            ctx.lineWidth = cellSize / 3;
            ctx.strokeStyle = '#c17a5c';
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#c17a5c';

            ctx.beginPath();
            ctx.moveTo(
              finalPath[0].x * cellSize + cellSize / 2,
              finalPath[0].y * cellSize + cellSize / 2
            );

            for (let i = 1; i < progress; i++) {
              ctx.lineTo(
                finalPath[i].x * cellSize + cellSize / 2,
                finalPath[i].y * cellSize + cellSize / 2
              );
            }

            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        }

        async function dijkstra(startX, startY, endX, endY) {
          const pq = [];
          const start = grid[startY][startX];
          start.distance = 0;
          pq.push(start);

          const dirs = [[1,0],[-1,0],[0,1],[0,-1]];

          while (pq.length) {
            pq.sort((a,b) => a.distance - b.distance);
            const cur = pq.shift();
            if (cur.visited) continue;
            cur.visited = true;
            cur.exploredTime = animationFrame;

            if (cur.x === endX && cur.y === endY) {
              reconstructPath(cur);
              return;
            }

            for (const [dx,dy] of dirs) {
              const nx = cur.x + dx;
              const ny = cur.y + dy;
              if (nx < 0 || ny < 0 || nx >= cols || ny >= rows) continue;
              const n = grid[ny][nx];
              if (n.isWall) continue;
              if (cur.distance + 1 < n.distance) {
                n.distance = cur.distance + 1;
                n.previous = cur;
                pq.push(n);
              }
            }

            await new Promise(r => setTimeout(r, 5));
          }
        }

        function reconstructPath(end) {
          finalPath = [];
          while (end) {
            finalPath.unshift(end);
            end = end.previous;
          }
          pathAnimationStart = animationFrame;
        }

        function animate() {
          animationFrame++;
          drawMaze();
          requestAnimationFrame(animate);
        }

        animate();
        setTimeout(() => dijkstra(1, 1, cols - 2, rows - 2), 1000);
      });
    </script>
  </body>
</html>
